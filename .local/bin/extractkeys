#!/bin/bash

# Define paths and phrases
path="${XDG_SOURCES_HOME:-${HOME}/.local/src}/suckless/dwm/thesiah"
readme_file="${XDG_DATA_HOME:-${HOME}/.local/share}/thesiah/thesiah.mom"
output_file="$path.mom"
temp_file_before="$path.tmp.before"
temp_file_after="$path.tmp.after"
start_phrase=".HEADING 2 \"Suckless\""
end_phrase=".HEADING 2 \"Other buttons\""

if [ -f "$path.mom" ]; then
	source_file="$path.mom"
else
	source_file="$path-default.mom"
fi

# Extract the section before the end marker
sed "/$end_phrase/,\$d" "$source_file" >"$temp_file_before"

# Extract the section from the end marker to the end of the file
sed -n "/$end_phrase/,\$p" "$source_file" >"$temp_file_after"

# Remove the contents between the start and end phrases, including the markers themselves
sed -i "/$start_phrase/,/$end_phrase/d" "$temp_file_before"

# Verify that the section has been removed
echo "Section between markers removed. Check $temp_file_before for correctness."

# Re-append the start marker since it was deleted
echo "$start_phrase" >>"$temp_file_before"

# Define your configuration files
mapfile -t config_files <<EOF
${XDG_SOURCES_HOME:-${HOME}/.local/src}/suckless/dwm/config.h
${XDG_SOURCES_HOME:-${HOME}/.local/src}/suckless/st/config.h
EOF

# Process each configuration file and append content
for file_path in "${config_files[@]}"; do
	project_name=$(basename "$(dirname "$file_path")")
	project_name=${project_name^^}

	echo ".HEADING 3 \"$project_name\"" >>"$temp_file_before"
	echo ".LI" >>"$temp_file_before"

	awk 'BEGIN {flag=0} /static[[:space:]]+(const[[:space:]]+)?(Key|Shortcut|Command|Button)[[:space:]]+(keys|cmdkeys|shortcuts|commands|buttons)[[:space:]]*\[\][[:space:]]*=[[:space:]]*{/ {flag=1} /\};/ {flag=0} flag' "$file_path" | while read -r line; do
		if [[ "$line" =~ \/\*.*\*\/ || "$line" =~ .*\"\\.* || "$line" =~ ^$ || "$line" =~ STACKKEYS || "$line" =~ TAGKEYS || "$line" =~ static\ Key\ cmdkeys || "$line" =~ ^\#.* ]]; then
			continue
		fi

		if [[ "$line" =~ ^\/\/.* ]]; then
			echo ".LIST OFF" >>"$temp_file_before"
			line=$(echo "$line" | sed -e 's/\/\/\s*//g' | awk '{for (i=1; i<=NF; i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2)); print}')
			output_line=".HEADING 9 \"$line\""
			echo "$output_line" >>"$temp_file_before"
			echo ".LI" >>"$temp_file_before"
			continue
		fi

		if [[ "$line" =~ static\ const|static\ Shortcut ]]; then
			echo ".LIST OFF" >>"$temp_file_before"
			output_line=".HEADING 8 \"INSERT MODE\""
			echo "$output_line" >>"$temp_file_before"
			echo ".LI" >>"$temp_file_before"
			continue
		fi

		if [[ "$line" =~ static\ Command ]]; then
			echo ".LIST OFF" >>"$temp_file_before"
			output_line=".HEADING 8 \"COMMAND MODE\""
			echo "$output_line" >>"$temp_file_before"
			echo ".LI" >>"$temp_file_before"
			continue
		fi

		line=$(
			echo "$line" | sed -e "
                                  s/\s*{\s*\(.*\)\s*}\,\s*/\1/g;
                                  s/[[:space:]]//g;
                                  s/XK_//g;
                                  s/MODKEY/MOD/g;
                                  s/MODKEY2/MOD2/g;
                                  s/ShiftMask/Shift/g;
                                  s/ControlMask/Ctrl/g;
                                  s/Escape/Esc/g;
                                  s/|/+/g;
                                  s/{0,/{/g;
                                  s/,0//g;
                                  s/{\(\w\+\),\(\w\+\)}/{\1+\2}/g;
                                  s/{\(\w\+\),\(\w\+\),\(\w\+\)}/{\1+\2+\3}/g;
                                  s/{\(\w\+\),\(\w\+\),\(\w\+\),\(\w\+\)}/{\1+\2+\3+\4}/g
                                  "
		)

		modkey=$(echo "$line" | awk -F',' '{print $1}' | sed -e "s/^{\(.*\)}$/\1/g;s/^0//g")
		key=$(echo "$line" | awk -F',' '{print $2}' | sed -e "s/^{\(.*\)}$/\1/g;s/+//g")
		func=$(echo "$line" | awk -F',' '{print $3}')
		args=$(echo "$line" | cut -d',' -f4-)

		if [[ -z "$modkey" ]]; then
			output_line="\\f(CW${key}\\fP \\(en ${func} ${args}"
		else
			output_line="\\f(CW${modkey}+${key}\\fP \\(en ${func} ${args}"
		fi

		echo ".ITEM" >>"$temp_file_before"
		echo "$output_line" >>"$temp_file_before"
	done

	echo ".LIST OFF" >>"$temp_file_before"
done

# Append the latter part of the document that follows the end marker
cat "$temp_file_after" >>"$temp_file_before"

# Replace the original file with the updated content
mv -f "$temp_file_before" "$output_file"
cp -f "$output_file" "$readme_file"

# Clean up the temporary after-section file
rm -f "$temp_file_after"

notify-send "üëç Operation completed successfully."
