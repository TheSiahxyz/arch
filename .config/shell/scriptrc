#!/bin/sh

###########################################################################################
###########################################################################################
### --- Source Plugins --- ###
# Add Files
zsh_source_plugin() {
  for file in "$@"; do
    [ -f "$ZPLUGINDIR/$file" ] && source "$ZPLUGINDIR/$file"
  done
}

# Add Plugins
zsh_add_plugins() {
  for plugin in "$@"; do
    local PLUGIN_NAME=$(echo $plugin | cut -d "/" -f 2)
    local PLUGIN_PATH="$ZPLUGINDIR/$PLUGIN_NAME"

    if [ -d "$PLUGIN_PATH" ]; then
      zsh_source_plugin "$PLUGIN_NAME/$PLUGIN_NAME.plugin.zsh"
      zsh_source_plugin "$PLUGIN_NAME/$PLUGIN_NAME.zsh"
    else
      if [ "$(echo $plugin | cut -d "/" -f 1)" = "ohmyzsh" ]; then
        if [ ! -d "$ZPLUGINDIR/oh-my-zsh" ]; then
          git clone --depth=1 https://github.com/ohmyzsh/ohmyzsh.git "$ZPLUGINDIR/oh-my-zsh" &>/dev/null
        fi

        local OHMYZSH_PLUGIN_PATH="$ZPLUGINDIR/oh-my-zsh/plugins/$PLUGIN_NAME"
        cp -r "$OHMYZSH_PLUGIN_PATH" "$ZPLUGINDIR/" &>/dev/null
        rm -rf "$ZPLUGINDIR/oh-my-zsh" &>/dev/null
      else
        git clone "https://github.com/$plugin.git" "$PLUGIN_PATH" &>/dev/null
      fi
      chmod +x "$PLUGIN_PATH"
    fi
  done
}

# Update Plugins
zsh_update_plugins() {
  # Define the plugin directory
  local ZPLUGINDIR="$HOME/.local/share/zsh"

  # Read and parse the list of active plugins from the configuration file
  # This time, extracting only the repository name (the part after the last '/')
  local ACTIVE_PLUGINS=($(grep '^[[:space:]]*"[^"]\+"' ~/.config/zsh/plugins.zsh | sed 's|.*/\([^/"]*\)".*|\1|'))

  # Loop over each directory in the plugin directory
  local PLUGIN_NAME
  for PLUGIN_DIR in "$ZPLUGINDIR"/*; do
    if [ -d "$PLUGIN_DIR" ]; then  # Check if it is a directory
      PLUGIN_NAME=$(basename "$PLUGIN_DIR")

      # Check if the plugin directory is not in the list of active plugins
      if [[ ! " ${ACTIVE_PLUGINS[*]} " =~ " $PLUGIN_NAME " ]]; then
        echo "Removing unused plugin: $PLUGIN_NAME"
        rm -rf "$PLUGIN_DIR"
      fi
    fi
  done
}


source_packages() {
  for package in ${(k)source_packages}; do
    if command -v $package >/dev/null; then
      args=(${(s: :)source_packages[$package]})
      eval "$($package init zsh $args)"
    fi
  done
}


###########################################################################################
###########################################################################################
### --- Change Names --- ###
cnt() {
  if [ $# -ne 2 ]; then
    echo "Usage: cnt <old_suffix> <new_suffix>"
    return 1
  fi

  local old_suffix="$1"
  local new_suffix="$2"
  local base_name="nvim"

  # Handle the case where the old suffix is '.'
  [ "$old_suffix" = "." ] && old_suffix=""
  [ "$new_suffix" = "." ] && new_suffix=""

  # Directories to be renamed
  local directories=(
    "$HOME/.config/$base_name"
    "$HOME/.local/share/$base_name"
    "$HOME/.local/state/$base_name"
    "$HOME/.cache/$base_name"
  )

  for dir in "${directories[@]}"; do
    if [ -d "$dir$old_suffix" ]; then
      mv "$dir$old_suffix" "$dir$new_suffix"
      echo "Renamed $dir$old_suffix to $dir$new_suffix"
    else
      echo "Directory $dir$old_suffix does not exist"
    fi
  done
}


###########################################################################################
###########################################################################################
### --- Color --- ###
ccolor() {
  awk 'BEGIN{
    s="/\\/\\/\\/\\/\\"; s=s s s s s s s s;
    for (colnum = 0; colnum<77; colnum++) {
      r = 255-(colnum*255/76);
      g = (colnum*510/76);
      b = (colnum*255/76);
      if (g>255) g = 510-g;
      printf "\033[48;2;%d;%d;%dm", r,g,b;
      printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
      printf "%s\033[0m", substr(s,colnum+1,1);
    }
    printf "\n";
  }'
}


###########################################################################################
###########################################################################################
### --- Config --- ###
ncf() {
  [ $# -gt 0 ] && zoxide query -i "$1" | xargs "${EDITOR}" && return
  local file
  file="$(zoxide query -l | fzf -1 -0 --no-sort +m)" && nvim "${file}" || return 1
}


###########################################################################################
###########################################################################################
### --- Copy --- ###
# file
cpf() {
  local clipboard_cmd=()
  local file
  clipboard_cmd=("xclip" "-selection" "clipboard")

  file=$(fzf --preview "cat {}")
  if [ -n "$file" ]; then
    # Use `sed` to delete only the last newline character
    cat "$file" | sed ':a;N;$!ba;s/\n$//' | "${clipboard_cmd[@]}"
  fi
}


###########################################################################################
###########################################################################################
### --- Docker --- ###
# Select a docker container to start and attach to
doca() {
  local cid
  cid=$(docker ps -a | sed 1d | fzf -1 -q "$1" | awk '{print $1}')

  [ -n "$cid" ] && docker start "$cid" && docker attach "$cid"
}

# Select a running docker container to stop
docs() {
  local cid
  cid=$(docker ps | sed 1d | fzf -q "$1" | awk '{print $1}')

  [ -n "$cid" ] && docker stop "$cid"
}

# Same as above, but allows multi selection:
docrm() {
  docker ps -a | sed 1d | fzf -q "$1" --no-sort -m --tac | awk '{ print $1 }' | xargs -r docker rm
}

# Select a docker image or images to remove
docrmi() {
  docker images | sed 1d | fzf -q "$1" --no-sort -m --tac | awk '{ print $3 }' | xargs -r docker rmi
}


###########################################################################################
###########################################################################################
### --- Firefox --- ###
bh() {
  local cols sep history_path open
  cols=$(( COLUMNS / 3 ))
  sep='{|}'
  profile_dir=$(find ~/.mozilla/firefox -type d -name "*.default-release*" | head -n 1)
  history_path="$profile_dir/places.sqlite"
  open=xdg-open
  tmp_history_dir="${XDG_CACHE_HOME:-$HOME/.cache}/tmp/history"
  tmp_history_file="$tmp_history_dir/history.sqlite"

  mkdir -p "$tmp_history_dir"
  command cp -f "$history_path" "$tmp_history_file"

  sqlite3 -separator "$sep" "$tmp_history_file" \
    "SELECT substr(p.title, 1, $cols) || '$sep' || p.url
     FROM moz_places p
     JOIN moz_historyvisits hv ON hv.place_id = p.id
     ORDER BY hv.visit_date DESC LIMIT 100" |
  awk -F "$sep" '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' |
  fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs -r $open > /dev/null 2> /dev/null
}

bm() {
    profile_dir=$(find ~/.mozilla/firefox -type d -name "*.default-release*" | head -n 1)
    bookmarks_path="$profile_dir/places.sqlite"
    tmp_bookmark_dir="${XDG_CACHE_HOME:-$HOME/.cache}/firefox_tmp"
    tmp_bookmark_file="$tmp_bookmark_dir/bookmark.sqlite"
    mkdir -p "$tmp_bookmark_dir"
    command cp -f "$bookmarks_path" "$tmp_bookmark_file"
    sqlite_query="
      SELECT b.title || ' | ' || p.url AS bookmark
      FROM moz_bookmarks b
      JOIN moz_places p ON b.fk = p.id
      WHERE b.type = 1 AND p.url LIKE 'http%' AND b.title NOT NULL
      ORDER BY b.dateAdded DESC;
    "
    choice=$(sqlite3 "$tmp_bookmark_file" "$sqlite_query" \
              | fzf --ansi --delimiter='|' --with-nth=1..-2 \
              | cut -d'|' -f2)
    if [ -n "$choice" ]; then
        xdg-open "$choice"
    fi
}


###########################################################################################
###########################################################################################
### --- Goto --- ###
# files in root
ff() {
  local file
  file=$(find "$HOME" -type f | fzf) && cd "$(dirname "$file")"
}

# files in sub
fF() {
  local file
  file=$(find . -type f | fzf) && nvim "$file"
}

# directory
fD() {
  cd $(find * -type d | fzf)
}

# search bin
se() {
	choice="$(find ~/.local/bin -mindepth 1 -printf '%P\n' | fzf)"
	[ -f "$HOME/.local/bin/$choice" ] && $EDITOR "$HOME/.local/bin/$choice"
}


###########################################################################################
###########################################################################################
### --- help --- ###
alias bathelp='bat --plain --language=help'
help() {
  # "$@" help 2>&1 | bathelp
  "$@" --help 2>&1 | bathelp
}


###########################################################################################
###########################################################################################
### --- Last Command Output --- ###
insert-last-command-output() {
  LBUFFER+="$(eval $history[$((HISTCMD-1))])"
}


###########################################################################################
###########################################################################################
### --- lf --- ###
lfcd () {
    tmp="$(mktemp -uq)"
    trap 'rm -f $tmp >/dev/null 2>&1 && trap - HUP INT QUIT TERM PWR EXIT' HUP INT QUIT TERM PWR EXIT
    lf -last-dir-path="$tmp" "$@"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && cd "$dir"
    fi
}


###########################################################################################
###########################################################################################
### --- mkcd --- ###
mkcd() { mkdir -p "$@" && cd "$_"; }


###########################################################################################
###########################################################################################
### --- Mount --- ###
mtl() {
  if [ $# -lt 1 ]; then
    echo "Usage: mtl <ip_address>"
    return 1
  fi

  ip_address="$1"

  # List available shares on the specified IP address.
  smbclient -L "$ip_address"
}

cmt() {
  local target_dir=~/Media/share/

  if [ $# -gt 0 ]; then
    # Construct the full target directory path.
    target_dir+=${@// /\\ }
  fi

  if [ ! -d "$target_dir" ]; then
    mkdir -p "$target_dir"
  fi

  cd "$target_dir" || return
}

mt() {
  if [ $# -lt 2 ]; then
    echo "Usage: mtw <ip_address> <share_name1> [<share_name2> ...]"
    return 1
  fi

  ip_address="$1"
  shift

  # Iterate over each share name provided.
  for share_name in "$@"; do
    # Check if the mount directory exists; create it if it doesn't.
    if [ ! -d ~/Media/share/"$share_name" ]; then
      echo "Creating mount point ~/Media/share/$share_name."
      mkdir -p ~/Media/share/"$share_name"
    fi

    # Attempt to mount the shared folder.
    echo "Mounting //$ip_address/$share_name to ~/Media/share/$share_name."
    sudo mount -t cifs //$ip_address/$share_name ~/Media/share/"$share_name" -o user=anonymous,password= || {
      echo "Failed to mount //$ip_address/$share_name."
      return 1
    }
  done
}

umt() {
  if [ $# -lt 1 ]; then
    echo "Usage: umtw <share_name1> [<share_name2> ...]"
    return 1
  fi

  # Iterate over each share name provided.
  for share_name in "$@"; do
    # Attempt to unmount the shared folder.
    echo "Unmounting ~/Media/share/$share_name."
    sudo umount -l ~/Media/share/"$share_name" || {
      echo "Failed to unmount ~/Media/share/$share_name."
      return 1
    }
  done
}


###########################################################################################
###########################################################################################
### --- neovim --- ###
# folder
cnf() {
  local base_dir="${XDG_DOTFILES_DIR:-$HOME/.dotfiles}/.config"     # Base directory for Neovim configs
  local target_dir="${XDG_CONFIG_HOME:-$HOME/.config}/nvim"             # Target directory for active Neovim config
  local target_share="${XDG_DATA_HOME:-$HOME/.local/share}/nvim"        # Neovim"s share directory
  local target_state="${XDG_STATE_HOME:-$HOME/.local/state}/nvim"       # Neovim"s state directory
  local target_cache="${XDG_CACHE_HOME:-$HOME/.cache}/nvim"             # Neovim"s cache directory

  # Explicitly list your configuration options
  local configs=("Default" "TheSiahxyz" "NvChad" "LazyVim")
  local selected_dir=$(printf "%s\n" "${configs[@]}" | fzf --prompt=" Neovim Config  " --height 50% --layout=reverse --border --exit-0)

  # Check if a configuration was selected
  [[ -z $selected_dir ]] && return 1

  # Default configuration
  if [[ $selected_dir == "Default" ]]; then
    echo "Clearing the Neovim configuration directory..."
    rm -rf "$target_dir" "$target_share" "$target_state" "$target_cache" &>/dev/null
    echo "Switched to the base Neovim configuration."
    return 0
  fi

  # Construct the full path of the selected configuration
  local config_path="$base_dir/$selected_dir"
  echo "$config_path"

  # Clear existing configurations if confirmed by the user
  echo -n "This will overwrite existing configurations. Continue? (y/n) "
  read reply
  if [[ $reply =~ ^[Yy]$ ]]; then
    echo "Clearing existing Neovim configurations..."
    rm -rf "$target_dir" "$target_share" "$target_state" "$target_cache" &>/dev/null
    mkdir -p "$target_dir" "$target_share" "$target_state" "$target_cache" &>/dev/null
  else
    echo "Operation cancelled."
    return 2
  fi

  # Copy the selected configuration to the target directories
  if [[ -d "$config_path" ]]; then
    cp -r "$config_path/." "$target_dir" > /dev/null 2>&1
    echo "Successfully applied $selected_dir configuration."
    shortcuts >/dev/null
  else
    echo "Configuration directory for $selected_dir does not exist."
    return 3
  fi
}

# switch
nvs() {
  items=("Default" "TheSiahxyz" "LazyVim" "NvChad")
  config=$(printf "%s\n" "${items[@]}" | fzf --prompt=" Neovim Config  " --height=~50% --layout=reverse --border --exit-0)
  [[ -z $config ]] && return 0
  NVIM_APPNAME=$config nvim $@
}

###########################################################################################
###########################################################################################
### --- Paste --- ###
# init
pasteinit() {
  OLD_SELF_INSERT=${${(s.:.)widgets[self-insert]}[2,3]}
  zle -N self-insert url-quote-magic
}

###########################################################################################
###########################################################################################
### --- Password --- ###
pqr() {
  pass otp uri -q $1
}

pqri() {
  pass otp insert $1
}

pss() {
  pass show $(find $PASSWORD_STORE_DIR -type f -name '*.gpg' | sed 's|^''$PASSWORD_STORE_DIR/||; s/\.gpg$//' | fzf)
}

psc() {
  pass show -c $(find $PASSWORD_STORE_DIR -type f -name '*.gpg' | sed 's|^''$PASSWORD_STORE_DIR/||; s/\.gpg$//' | fzf)
}


###########################################################################################
###########################################################################################
### --- Sudo --- ###
__sudo-replace-buffer() {
  local old=$1 new=$2 space=${2:+ }
  if [[ $CURSOR -le ${#old} ]]; then
    BUFFER="${new}${space}${BUFFER#$old }"
    CURSOR=${#new}
  else
    LBUFFER="${new}${space}${LBUFFER#$old }"
  fi
}
sudo-command-line() {
  [[ -z $BUFFER ]] && LBUFFER="$(fc -ln -1)"
  local WHITESPACE=""
  if [[ ${LBUFFER:0:1} = " " ]]; then
    WHITESPACE=" "
    LBUFFER="${LBUFFER:1}"
  fi
  {
    local EDITOR=${SUDO_EDITOR:-${VISUAL:-$EDITOR}}
    if [[ -z "$EDITOR" ]]; then
      case "$BUFFER" in
        sudo\ -e\ *) __sudo-replace-buffer "sudo -e" "" ;;
        sudo\ *) __sudo-replace-buffer "sudo" "" ;;
        *) LBUFFER="sudo $LBUFFER" ;;
      esac
      return
    fi
    local cmd="${${(Az)BUFFER}[1]}"
    local realcmd="${${(Az)aliases[$cmd]}[1]:-$cmd}"
    local editorcmd="${${(Az)EDITOR}[1]}"
    if [[ "$realcmd" = (\$EDITOR|$editorcmd|${editorcmd:c}) \
      || "${realcmd:c}" = ($editorcmd|${editorcmd:c}) ]] \
      || builtin which -a "$realcmd" | command grep -Fx -q "$editorcmd"; then
      __sudo-replace-buffer "$cmd" "sudo -e"
      return
    fi
    case "$BUFFER" in
      $editorcmd\ *) __sudo-replace-buffer "$editorcmd" "sudo -e" ;;
      \$EDITOR\ *) __sudo-replace-buffer '$EDITOR' "sudo -e" ;;
      sudo\ -e\ *) __sudo-replace-buffer "sudo -e" "$EDITOR" ;;
      sudo\ *) __sudo-replace-buffer "sudo" "" ;;
      *) LBUFFER="sudo $LBUFFER" ;;
    esac
  } always {
    LBUFFER="${WHITESPACE}${LBUFFER}"
    zle && zle redisplay # only run redisplay if zle is enabled
  }
}


###########################################################################################
###########################################################################################
### --- Tmux --- ###
# kill
tmk() {
    local sessions
    sessions="$(tmux ls|fzf --exit-0 --multi)"  || return $?
    local i
    for i in "${(f@)sessions}"
    do
        [[ $i =~ '([^:]*):.*' ]] && {
            echo "Killing $match[1]"
            tmux kill-session -t "$match[1]"
        }
    done
}

# new or switch
tmn() {
  [[ -n "$TMUX" ]] && change="switch-client" || change="attach-session"
  if [ $1 ]; then
    tmux $change -t "$1" 2>/dev/null || (tmux new-session -d -s $1 && tmux $change -t "$1"); return
  fi
  session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --exit-0) &&  tmux $change -t "$session" || echo "No sessions found."
}

# select
tms() {
  local session
  session=$(tmux list-sessions -F "#{session_name}" \
              | fzf --query="$1" --select-1 --exit-0) &&
  tmux switch-client -t "$session"
}


###########################################################################################
###########################################################################################
### --- Vi Mode --- ###
# Change cursor shape for different vi modes.
zle-keymap-select () {
    case $KEYMAP in
        vicmd) echo -ne '\e[1 q';;      # block
        viins|main) echo -ne '\e[5 q';; # beam
    esac
}
zle-line-init() {
    zle -K viins # initiate `vi insert` as keymap (can be removed if `bindkey -V` has been set elsewhere)
    echo -ne "\e[5 q"
}
preexec() { echo -ne '\e[5 q' ;} # Use beam shape cursor for each new prompt.


###########################################################################################
###########################################################################################
### --- Virtual Env --- ###
# Create
createv() { python -m venv $XDG_DATA_HOME/venvs/"$1" }
# Activate
activev() { source $XDG_DATA_HOME/venvs/"$1"/bin/activate }
# List
listv() {
  local venvs_dir="$XDG_DATA_HOME/venvs"
  local venvs=("$venvs_dir"/*)

  if [ ${#venvs[@]} -eq 0 ]; then
    echo "No venvs"
    return 0
  fi

  echo "venvs list:"
  for venv in "${venvs[@]}"; do
    if [ -d "$venv" ]; then
      echo " 󰢔 $(basename "$venv")"
    fi
  done
}
# Delete
deletev() {
  local env_dir="$XDG_DATA_HOME/venvs"
  local options=($(find "$env_dir" -maxdepth 1 -mindepth 1 -type d -exec basename {} \;))
  options+=("Delete All")

  # Prompt user to select a virtual environment or choose an option to delete all
  local selected_env=$(printf "%s\n" "${options[@]}" | fzf --prompt="venvs  " --height=~50% --layout=reverse --border --exit-0)

  if [[ -z $selected_env ]]; then
    echo "No venvs selected"
    return 0
  elif [[ $selected_env == "Delete All" ]]; then
    rm -rf "$env_dir"/*
    echo "All venvs deleted"
  else
    rm -rf "$env_dir/$selected_env"
    echo "$selected_env deleted"
  fi
}
